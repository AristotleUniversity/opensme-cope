/* Generated by Together */

package eu.opensme.cope.recommenders;

import eu.opensme.cope.domain.ReuseProject;
import eu.opensme.cope.recommenders.entities.ClassAnalysis;
import eu.opensme.cope.recommenders.entities.ClassCluster;
import eu.opensme.cope.recommenders.entities.ClassClusterPartcipant;
import eu.opensme.cope.recommenders.entities.DependenciesClassCluster;
import eu.opensme.cope.recommenders.entities.Project;
import eu.opensme.cope.util.FileSystemHandlerUtil;
import eu.opensme.cope.util.HibernateUtil;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

abstract public class Recommender {
    
    protected ReuseProject reuseProject;
    protected Project project;
    protected File clustersExportDir;
    protected ArrayList<ClassCluster> clusters;

    public Recommender (ReuseProject reuseProject) {
        this.reuseProject = reuseProject;
        this.project = reuseProject.getProject();
        this.clusters = new ArrayList<ClassCluster>();
    }
            
    protected void cleanClusterDir(File clustersExportDir) {
        deleteDirectoryContent(clustersExportDir);
        clustersExportDir.mkdirs();
    }

    public abstract void createClusters() throws IOException;

    /**
     * Deletes all files and subdirectories under dir. Returns true if all deletions 
     * were successful. If a deletion fails, the method stops attempting to delete and 
     * returns false.
     * 
     * @param dir
     * @return 
     */
    protected boolean deleteDirectoryContent(File dir) {
        if (dir.isDirectory()) {
            String[] children = dir.list();
            for (int i = 0; i < children.length; i++) {
                boolean success = deleteDirectoryContent(new File(dir, children[i]));
                if (!success) {
                    return false;
                }
            }
        }
        // The directory is now empty so delete it
        return dir.delete();
    }

    protected ClassCluster classNamesToClassCluster(ArrayList<File> classNames, String clustersName) {
        //create class cluster participants from ClassAnalysis objects
        ArrayList<ClassClusterPartcipant> clusterParticipants = classNamesToClassParticipants(classNames);
        //create new cluster
        ClassCluster theCluster = new DependenciesClassCluster(clustersName, clusterParticipants, reuseProject);

        return theCluster;
    }

    public void alterClusterAfterUsersIntervension(ArrayList<File> classNames, String clustersName) {
        File clusterToChangeDir = new File(clustersExportDir + File.separator + clustersName);

        if (classNames.isEmpty()) {
            //clean cluster's directory
            cleanClusterDir(clusterToChangeDir);
        } else {
            //create class cluster participants from ClassAnalysis objects
            ArrayList<ClassClusterPartcipant> clusterParticipants = classNamesToClassParticipants(classNames);
            //create new cluster
            ClassCluster changedCluster = new DependenciesClassCluster(clustersName, clusterParticipants, reuseProject);
            //clean cluster's directory
            cleanClusterDir(clusterToChangeDir);
            //create physical cluster
            changedCluster.createPhysicalCluster(clusterToChangeDir);
            //create UML graph
            changedCluster.createClustersUMLGraph(clusterToChangeDir);
        }
    }

    public ArrayList<ClassCluster> getClusters() {
        return clusters;
    }
    
    public ArrayList<ClassClusterPartcipant> classNamesToClassParticipants(ArrayList<File> classNames) {

        FileSystemHandlerUtil fsh = new FileSystemHandlerUtil();

        //For each of the nodes of the cluster create copy the 
        //corresponding source file in the directory of the cluster
        Iterator members = classNames.iterator();

        ArrayList<ClassAnalysis> cas = new ArrayList<ClassAnalysis>();
        ArrayList<ClassClusterPartcipant> caCollection = new ArrayList<ClassClusterPartcipant>();

        SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
        Session session = sessionFactory.openSession();

        while (members.hasNext()) {

            File className = (File) members.next();

            String correctClassName = fsh.convertFilePathToCOPEDBClassAnalysisName(className);

            //Find the corresponding ClassAnalysis object
            String q = "from ClassAnalysis ca where ca.project=:project and ca.name=:name";
            Query query = session.createQuery(q);
            query.setParameter("project", project);
            query.setParameter("name", correctClassName);

            ClassAnalysis temp = (ClassAnalysis) query.uniqueResult();
            cas.add(temp);
        }
        for (int i = 0; i < cas.size(); i++) {
            double specificity = calculateClassesSpecificity(cas.get(i), cas);
            ClassClusterPartcipant tempCP = new ClassClusterPartcipant(cas.get(i), specificity,"none");
            caCollection.add(tempCP);
        }
        session.close();

        return caCollection;
    }
    
    /**
     * 
     * @param ca
     * @param classes
     * @return 
     */
    protected double calculateClassesSpecificity(ClassAnalysis ca, List<ClassAnalysis> classes) {
        SessionFactory factory = HibernateUtil.getSessionFactory();
        Session session = factory.openSession();
        Query q = session.createQuery("select elements(ca.classesesForDependee) from ClassAnalysis ca where ca = :ca");
        q.setEntity("ca", ca);
        List<ClassAnalysis> dependees = q.list();
        int noOfDependeesInCluster = 0;
        for (ClassAnalysis c : classes) {
            if (dependees.contains(c)) {
                noOfDependeesInCluster++;
            }
        }

        double specificity = -999.999;

        //if there is only one class in the cluster the specificity is set to 1
        if (classes.size() == 1) {
            specificity = 1;
        } else { //else we are using the formula bellow
            specificity = (double) noOfDependeesInCluster / (double) (classes.size() - 1);

        }


        session.close();
        return specificity;
    }
    
}
